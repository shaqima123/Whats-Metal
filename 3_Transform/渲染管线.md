#啥是馒头(Metal)

## 渲染管线

回顾一下第一节中对渲染管线的简介：
> pipeline 就是渲染管线，是在渲染处理过程中顺序执行的一系列操作。这一套渲染流程在理论层面上都是统一的，所以不论是 OpenGL ES 的渲染管线还是 Metal 的渲染管线，在理解上都是相同的。pipeline 来源于生产车间的流水线作业，在渲染过程中，一个操作接一个操作进行，就如同流水线一样，这样的实现可以极大地提高渲染效率。整个渲染管线如同下图所示：

![pipeline.png](https://github.com/shaqima123/Resource/raw/master/WhatsMetal/pipeline.png)

渲染管线的大致流程为：顶点数据来源 -> 顶点着色器 -> 图元装配 ->
光栅化 -> 片元着色器 -> 拿到FrameBuffer 

#### 顶点数据来源

渲染管线中要做的第一步就是获取顶点。我们知道渲染一个 3D 的画面，它必定是由 n 个模型组成，而一个模型又是由 n 个由顶点连接的网格组成。所以顶点是一切的基础，我们可以通过 3D 模型去获取顶点，也可以通过自定义的顶点数据去获取顶点。而顶点描述器 vertexDescriptor 就是用于获取顶点的属性，比如顶点坐标、纹理坐标、法向量以及颜色等。

#### 顶点处理
在顶点处理的阶段，GPU 主要将传进来的所有顶点坐标做坐标转换，通过对顶点进行之间的转换得到顶点在渲染视图上的最终坐标。当然同时在这个阶段也可以进行顶点中光照和颜色属性的计算。
我们所写的顶点着色器代码就是在顶点处理的阶段通过 GPU 进行计算的。比如我们写一个最简单的顶点着色器代码：

```
struct VertexIn {
  float4 position [[ attribute(0) ]];
};

vertex float4 vertex_main(const VertexIn vertexIn [[ stage_in ]]) {
  return vertexIn.position;
}
```
以上代码申明了一个 VertexIn 的结构，其中只有 position 的成员变量，然后在 vertex_main 这个顶点着色器代码中，接收 VertexIn 结构的参数，然后将参数中的 position 以 float4 的数据类型传出。

那么顶点的数据源从哪里来呢？所有的顶点数据都是通过 model 的 mesh 拿到的，然后都被保存在 vertex buffer 中，并且是已经排序好了的。我们知道通过 vertex descriptor 可以告诉 GPU 顶点数据需要怎么读取。所以我们通过 vertex shader 的 [[ stage_in ]] 语法可以获取到当前 index 的顶点数据。

#### 图元装配
在顶点处理阶段之后，GPU 可以拿到一组组已经经过处理的顶点数据块。那么什么是图元呢？图元表示的就是一组表示顶点位置的顶点描述。在 Metal 中支持五种图元的类型，分别是点(Point)、线段(Line)、连续的线段(Line Strip)、三角形(Triangle)、连续的三角形(Triangle Strip)。

```
renderEncoder.drawIndexedPrimitives(type: .triangle,
                                                    indexCount: submesh.indexCount,
                                                    indexType: submesh.indexType,
                                                    indexBuffer: submesh.indexBuffer.buffer,
                                                    indexBufferOffset: submesh.indexBuffer.offset)
```

如上就是图元装配过程的代码，告诉 GPU 需要以三角形的图元去装配 vertex buffer 传入的顶点。

在图元装配的过程中